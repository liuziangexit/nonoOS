OK-用820初始化buddy
OK-实现buddy
OK-人肉测试buddy（我甚至写了自动化测试用例！）
OK-实现slab
OK-实现malloc
OK-高于物理内存的部分不做虚拟地址映射，这样有非法访问的时候可以直接page fault
OK-所有abort能改成panic就改panic，带有出错原因
OK-实现内核线程
OK-用户程序编译系统
OK-重新看下整个启动流程和内存布局的情况
OK-slab重新检查，加上注释。为什么不支持4M分配？
OK-实现记录物理-虚拟内存对应关系的一种数据结构
OK-vma
ok-4k小页映射
OK-加载用户程序到内存
OK-跑第一行用户态代码，然后返回
OK-用户进程/线程
OK-用户进程地址空间
OK-syscall返回值
OK-中断可以嵌套吗(可以)
OK-是不是没有清中断掩码？(应该是CPU做了)
OK-实现memory fence
OK-实现atomic int
OK-实现spinlock
OK-给现有的某些代码加锁（包括如果关了中断，这个中断会丢失吗？(不会)如果处理中断的时候又有中断，会怎么样？(会像递归调用函数那样)）
OK-实现timer
OK-完整实现task接口，线程创建、线程调度（包括K和U之间）、线程退出
OK-实现用户的malloc的按页内存分配
OK-exit
OK-想个办法访问地址0时候报错
OK-vma相邻合并
OK-重写有问题的virtual_memory_find_fit
OK-加上avl_node_init
OK-find_fit支持设置flags
OK-测一下第二次find_fit找出来的地方是不是正接着第一个findfit
OK-测试umalloc_pgfault
OK-实现ufree
OK-析构vm的时候回收用户malloc相关内存
OK-实现用户的malloc的页内内存分配
OK-实现task传参数
OK-画一下内核内存布局
OK-getpid
OK-实现系统调用 printf
OK-用户只需要调用那个中断就可以提权到ring0，修复这问题

-task返回值

-考虑一下switch_to里面没有储存eax有没有问题？
-实现内核之外的物理内存的页分配
-用户malloc使用FREE SPACE的内存

-实现简单调度算法
-实现mutex、信号量。可以按照java和c#的方式，用一种对象来实现
-sleep
-yield
-lock
-unlock
-wait
-notify

-实现用户态abort，只是abort用户进程
-实现nosh(nonoShell)
-重新考虑输入输出，主要是如何判断输入属于哪个进程
-实现系统调用scanf

-想办法看看taskswitch耗时多少，考虑怎么根据耗时动态计算时间片
-在物理机上运行

-看看libno里有没有需要单独实现用户态版本的函数
-运行 ASCII RayTracing
-整理编译系统，支持配置tool prefix

-给slab写一个buddy那样的测试用例
-安全问题1)内核线程栈溢出的处理 2)用户进程有没有可能访问到内核栈或代码
-考虑怎么检测内存泄漏
-文件系统
-实现页面swap

GUI
网络

多核心支持
