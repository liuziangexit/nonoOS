OK-用820初始化buddy
OK-实现buddy
OK-人肉测试buddy（我甚至写了自动化测试用例！）
OK-实现slab
OK-实现malloc
OK-高于物理内存的部分不做虚拟地址映射，这样有非法访问的时候可以直接page fault
OK-所有abort能改成panic就改panic，带有出错原因
OK-实现内核线程
OK-用户程序编译系统
OK-重新看下整个启动流程和内存布局的情况
OK-slab重新检查，加上注释。为什么不支持4M分配？
OK-实现记录物理-虚拟内存对应关系的一种数据结构
OK-vma
ok-4k小页映射
OK-加载用户程序到内存
OK-跑第一行用户态代码，然后返回
OK-用户进程/线程
OK-用户进程地址空间
OK-syscall返回值
OK-中断可以嵌套吗(可以)
OK-是不是没有清中断掩码？(应该是CPU做了)
OK-实现memory fence
OK-实现atomic int
OK-实现spinlock
-给现有的某些代码加锁（包括如果关了中断，这个中断会丢失吗？(不会)如果处理中断的时候又有中断，会怎么样？(会像递归调用函数那样)）
-完整实现task接口，包括传参、线程创建、线程调度（包括K和U之间）、线程退出
-实现timer
-实现mutex
-实现信号量
-实现简单调度算法
-实现基本的系统调用包括 getpid exit sleep yield lock unlock wait notify printf scanf
-vma相邻合并以及code review
-两段式中断处理，将关闭中断的时间减少到最小
-实现用户的malloc，包括1)页式内存分配2)页内内存分配
-看看libno里有没有需要单独实现用户态版本的函数
-运行 ASCII RayTracing
-文件系统
-给slab写一个buddy那样的测试用例
-安全问题1)内核线程栈溢出的处理 2)s用户进程有没有可能访问到内核栈或代码
-实现页面swap

实现stdarg（1.看下gcc默认是什么参数传递规范，然后用汇编啥的去实现）
GUI
多核心支持
加一个脚本文件来存tool prefix
加docker支持

-防止恶意elf文件造成安全问题